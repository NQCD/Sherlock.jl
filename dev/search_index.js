var documenterSearchIndex = {"docs":
[{"location":"#ClusterScripts.jl","page":"Home","title":"ClusterScripts.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis documentation is a work in progress. To find out what everything in the package does, the ClusterScripts.jl API docstrings are currently your best bet.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package contains functions to more efficiently distribute resources to MD simulations with NQCDynamics.jl on HPC clusters, including the ability to initialise simulations with all possible combinations of multiple variables. This can be useful to compare results across a range of initial parameters, or with a range of different models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"While NQCDynamics.jl provides the tools necessary to run ensemble simulations, and a means of parallelisation through SciML’s EnsembleAlgorithms, compatibility of different models with certain EnsembleAlgorithms isn’t guaranteed, nor will there necessarily be a notable gain in performance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Since many machine learning interatomic potentials are developed in Python, where the global interpreter lock prevents multithreading, thread parallelism provided by EnsembleAlgorithms tends not to work at all.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This leaves trivial taskfarming as the most viable option to parallelise the execution of multiple simulations across multiple HPC nodes.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package allows for the creation and aggregation of results for Single Instruction, multiple data (SIMD) workflows on HPC clusters.","category":"page"},{"location":"#How-to-build-an-SIMD-workflow","page":"Home","title":"How to build an SIMD workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"% diagram: input: Dict of parameters -> driver function -> output Tuple of parameters and results","category":"page"},{"location":"#Parameter-grid-searches","page":"Home","title":"Parameter grid searches","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ClusterScripts.jl contains functions to generate a \"queue\" of simulation parameters containing all possible combinations of multiple variables in a simulation. This allows for grid searches over multiple parameters, which could be used to compare e.g. different interatomic potentials over a range of different temperatures.","category":"page"},{"location":"","page":"Home","title":"Home","text":"% diagram for Dict structure","category":"page"},{"location":"","page":"Home","title":"Home","text":"% code example","category":"page"},{"location":"","page":"Home","title":"Home","text":"% note that handling of all these parameters needs to be built in your own code.","category":"page"},{"location":"#Parallel-workload-distribution-(file-based)","page":"Home","title":"Parallel workload distribution (file-based)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"% explain how jobs are created from a queue % explain how batching can be used to split into different size chunks % example for how to run these jobs on a cluster.","category":"page"},{"location":"#Aggregating-results","page":"Home","title":"Aggregating results","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"% explain how to aggregate file-based results back into a single file. % explain how the LazyLoader saves memory and load time.","category":"page"},{"location":"API/#ClusterScripts.jl-API","page":"API","title":"ClusterScripts.jl API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"Modules = [ClusterScripts]","category":"page"},{"location":"API/#ClusterScripts.ResultsLazyLoader","page":"API","title":"ClusterScripts.ResultsLazyLoader","text":"Struct to view into results files, loading full results only if directly accessed.\n\nIf parameters or derivedquantities are modified, remember to call save!() to update the file. Modifications to results outside those made by `concatenateresults!` will not be saved.\n\n\n\n\n\n","category":"type"},{"location":"API/#ClusterScripts.SimulationFile","page":"API","title":"ClusterScripts.SimulationFile","text":"Struct to hold file paths and provide some basic functionality for working with them.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.setindex!-Tuple{ResultsLazyLoader, Any, Int64}","page":"API","title":"Base.setindex!","text":"Base.setindex!(loader::ResultsLazyLoader, val, i::Int)\n\nWarning: This overwrites the entire results group! use loader[i]=append!(deepcopy(loader[i]), X) or similar to append to existing data.\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.build_job_queue-Tuple{Dict, Dict, Function}","page":"API","title":"ClusterScripts.build_job_queue","text":"build_job_queue(fixed_parameters::Dict, variables::Dict, postprocessing_function::Function)\n\nReturns a Vector of all unique combinations of values in variables merged with fixed_parameters. By specifying a postprocessing_function, further actions can be performed each of the elements in the resulting vector.\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.build_job_queue-Tuple{Dict, Dict}","page":"API","title":"ClusterScripts.build_job_queue","text":"build_job_queue(fixed_parameters::Dict, variables::Dict)\n\nReturns a Vector of all unique combinations of values in variables merged with fixed_parameters. Each key in variables should be a list of possible values for that parameter. (Trivially, a length 1 list)\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.convert_to_grouped_jld2-Tuple{Any, Any, Any}","page":"API","title":"ClusterScripts.convert_to_grouped_jld2","text":"convert_to_grouped_jld2(filename, results_data, simulation_queue; trajectories_key = \"trajectories\")\n\nConverts the results format of an ungrouped JLD2 file to the grouped format and adds the simulation parameters from a simulation queue.\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.convert_to_grouped_jld2-Tuple{Any, Any}","page":"API","title":"ClusterScripts.convert_to_grouped_jld2","text":"convert_to_grouped_jld2(filename, results_data)\n\nConverts the results format of an ungrouped JLD2 file to the grouped format. Warning: This method yields undefined simulation parameters which normally shouldn't occur in grouped JLD2 files.\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.create_results_file-Tuple{String, String, String}","page":"API","title":"ClusterScripts.create_results_file","text":"create_results_file(output_filename::String, glob_pattern::String, queue_file::String;trajectories_key=\"trajectories\", truncate_times=true)\n\nCompresses all results from a simulation queue back into a single file. Any missing outputs are reported as warnings and will be undefined in the final output.\n\nThis file contains the results of all jobs in the queue, as well as the input parameters for each job in the following format:\n\nfile[\"results\"] contains an Array with the same dimensions as the input parameters.\nEach element of file[\"results\"] contains a tuple of the output from the simulation and the input parameters for that simulation.\nSimulation output will always be a vector, even for single trajectories, to allow for consistent analysis functions that are independent of trajectory numbers.\n\nArguments output_filename::String: The name of the file to save the results to.\n\nglob_pattern::String: A glob pattern to match all files to merge.\n\nqueue_file::String: The file containing the input parameters for the simulation queue.\n\ntrajectories_key::String: The key in the input parameters dictionary which describes batching behaviour. (typically \"trajectories\", since we want to farm out trajectories to workers)\n\ntruncate_times::Bool: If true, the time array in the output will be truncated to the final value only. Useful to save space when a large number of identical trajectories are run with short time steps.\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.merge_pmap_results-Tuple{AbstractArray}","page":"API","title":"ClusterScripts.merge_pmap_results","text":"merge_pmap_results(simulation_output;trajectories_key=\"trajectories\", ensemble_key=\"ensemble_algorithm\")\nMerger function for NQCD simulation results. Takes a vector of (NQCD output, input_parameters) tuples and merges together all unique combinations of simulation parameters, adding the number of trajectories together as if the simulation was run as a larger ensemble.\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.pmap_queue-Tuple{Any, Vector{Dict}}","page":"API","title":"ClusterScripts.pmap_queue","text":"pmap_queue(target_function::Function, input_list::Vector{Dict}; trajectories_key=\"trajectories\", ensemble_key=\"ensemble_algorithm\", tmp_dir=\"tmp/\", checkpoint_frequency=0, sort_variable=\"\")\nSplits a list of input parameters into smaller operations for better multiprocessing, then runs the target function on the list of inputs and merges the results back together again.\n\nArguments similar to pmap: loadbalance_queue(f, args)\n\n`trajectories_key`: Dictionary key in input parameter dictionary holding the number of trajectories for target_function to perform.\n\n`ensemble_key`: Dictionary key in input parameters containing the EnsembleAlgorithm for NQCD to use.\n\n`tmp_dir`: Location for checkpoint files.\n\n`checkpoint_frequency`: Number of operations per worker to perform before saving to a tempfile. (Default is 1 per worker - the faster and more stable, the higher to go)\n\n`sort_variable`: Offers the option to sort all jobs generated by a certain input parameter to group tasks of similar size together.\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.push_nqcd_outputs!-Tuple{Any, Any}","page":"API","title":"ClusterScripts.push_nqcd_outputs!","text":"push_nqcd_outputs!!(first_output, other_outputs...)\n\nLike a push!() function, but it also puts `first_output` into a vector if it wasn't already and adds the number of trajectories together.\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.save!-Tuple{ResultsLazyLoader}","page":"API","title":"ClusterScripts.save!","text":"save!(loader::ResultsLazyLoader)\n\nUpdates the stored parameters and derived quantities inside a grouped JLD2 file. Run this function after modifying loader.parameters or loader.derived_quantities to save the changes.\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.serialise_queue!-Tuple{Vector{<:Dict}}","page":"API","title":"ClusterScripts.serialise_queue!","text":"serialise_queue!(input_dict_tensor::Vector{<: Dict{<: Any}}; trajectories_key=\"trajectories\", filename=\"simulation_parameters.jld2\")\n\nPerforms batching on the Array of input parameters for multithreading/multiprocessing. By assigning the key \"batchsize\" in the input parameters, each simulation job will be split into as many batches as necessary to run the required number of trajectories. The default batch size is 1, i.e. trivial taskfarming.\n\nSet \"trajectories_key\" in case jobs should be split by something different.\n\nSet \"filename\" to save the resulting batch queue somewhere different than simulation_parameters.jld2.\n\n\n\n\n\n","category":"method"},{"location":"API/#ClusterScripts.update_results_file-NTuple{4, String}","page":"API","title":"ClusterScripts.update_results_file","text":"update_results_file(input_file::String, glob_pattern::String, queue_file::String, output_file::String; trajectories_key=\"trajectories\", file_format::String=\"jld2\")\n\nMerges existing results from an ungrouped JLD2 file into a new ungrouped JLD2 file.\n\nArguments output_filename::String: The name of the file to save the results to.\n\nglob_pattern::String: A glob pattern to match all files to merge.\n\nqueue_file::String: The file containing the input parameters for the simulation queue.\n\ntrajectories_key::String: The key in the input parameters dictionary which describes batching behaviour. (typically \"trajectories\", since we want to farm out trajectories to workers)\n\n\n\n\n\n","category":"method"}]
}
